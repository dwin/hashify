package metrics

import (
	"sync/atomic"
	"time"

	"github.com/prometheus/client_golang/prometheus"
)

type Collector struct {
	startTime      time.Time
	keyGenerations *prometheus.HistogramVec
	hashOperations *prometheus.CounterVec
	hashCounter    atomic.Uint64
	keyGenCounter  atomic.Uint64
}

func (c *Collector) KeyGenerations(length int) {
	c.keyGenCounter.Add(1)
	c.keyGenerations.WithLabelValues().Observe(float64(length))
}

func (c *Collector) HashOperations(algorithm, digestFormat string) {
	c.hashCounter.Add(1)
	c.hashOperations.With(prometheus.Labels{"algorithm": algorithm, "digest_format": digestFormat}).Inc()
}

func (c *Collector) HashCount() uint64 {
	return c.hashCounter.Load()
}

func (c *Collector) KeyGenCount() uint64 {
	return c.keyGenCounter.Load()
}

func (c *Collector) Uptime() time.Duration {
	return time.Since(c.startTime)
}

func NewCollector() *Collector {
	c := &Collector{
		startTime: time.Now(),
		keyGenerations: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "key_generations_total",
				Help: "Number of keys generated by hashify.",
				// Buckets based on size in bytes, from 1 - 256 bytes.
				Buckets: []float64{1, 2, 4, 8, 16, 32, 64, 128, 256},
			},
			[]string{},
		),
		hashOperations: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "hash_operations_total",
				Help: "Number of hashes generated by hashify.",
			},
			[]string{"algorithm", "digest_format"},
		),
	}
	prometheus.MustRegister(c.keyGenerations, c.hashOperations)
	c.hashCounter.Store(0)
	c.keyGenCounter.Store(0)
	return c
}
