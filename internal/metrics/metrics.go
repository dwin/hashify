package metrics

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"sync/atomic"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/rs/zerolog/log"
)

const serverTimeout = 10 * time.Second

type Collector struct {
	startTime      time.Time
	keyGenerations *prometheus.HistogramVec
	hashOperations *prometheus.CounterVec
	hashCounter    atomic.Uint64
	keyGenCounter  atomic.Uint64
}

func (c *Collector) KeyGenerations(length int) {
	c.keyGenCounter.Add(1)
	c.keyGenerations.WithLabelValues().Observe(float64(length))
}

func (c *Collector) HashOperations(algorithm, digestFormat string) {
	c.hashCounter.Add(1)
	c.hashOperations.With(prometheus.Labels{"algorithm": algorithm, "digest_format": digestFormat}).Inc()
}

func (c *Collector) HashCount() uint64 {
	return c.hashCounter.Load()
}

func (c *Collector) KeyGenCount() uint64 {
	return c.keyGenCounter.Load()
}

func (c *Collector) Uptime() time.Duration {
	return time.Since(c.startTime)
}

func NewCollector() *Collector {
	c := &Collector{
		startTime: time.Now(),
		keyGenerations: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name: "key_generations_total",
				Help: "Number of keys generated by hashify.",
				// Buckets based on size in bytes, from 1 - 256 bytes.
				Buckets: []float64{1, 2, 4, 8, 16, 32, 64, 128, 256},
			},
			[]string{},
		),
		hashOperations: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "hash_operations_total",
				Help: "Number of hashes generated by hashify.",
			},
			[]string{"algorithm", "digest_format"},
		),
	}
	collectors := []prometheus.Collector{c.keyGenerations, c.hashOperations}
	for _, collector := range collectors {
		if err := prometheus.Register(collector); err != nil && !errors.As(err, &prometheus.AlreadyRegisteredError{}) {
			log.Fatal().Err(err).Msg("failed to register prometheus collector")
		}
	}

	c.hashCounter.Store(0)
	c.keyGenCounter.Store(0)
	return c
}

func RunHTTPMetricsServer(ctx context.Context, addr string) error {
	promHandler := promhttp.Handler()

	mux := http.NewServeMux()
	mux.Handle("/metrics", promHandler)

	httpServer := http.Server{
		Addr:              addr,
		Handler:           mux,
		ReadHeaderTimeout: serverTimeout,
		ReadTimeout:       serverTimeout,
		WriteTimeout:      serverTimeout,
	}

	go func() {
		<-ctx.Done()
		httpServer.Shutdown(ctx)
	}()

	log.Info().Msgf("Starting HTTP Metrics Server on '%s'", addr)

	// Start HTTP Server
	if err := httpServer.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		return fmt.Errorf("http server error: %w", err)
	}

	return nil
}
